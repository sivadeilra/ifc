//! Generates Rust code from IFC modules

#![allow(unused_imports)]
#![forbid(unused_must_use)]

use anyhow::{bail, Result};
use ifc::*;
use log::{debug, info, trace};
use proc_macro2::Span;
use proc_macro2::TokenStream;
use quote::*;
use std::collections::HashSet;
use syn::Ident;
use syn::*;

#[derive(Clone, Debug)]
pub struct Options {
    /// Derive Debug impls for types, by default
    pub derive_debug: bool,
}

impl Default for Options {
    fn default() -> Self {
        Self { derive_debug: true }
    }
}

struct Gen<'a> {
    ifc: &'a Ifc,
    options: &'a Options,
    #[allow(dead_code)]
    wk: WellKnown,
}

#[allow(dead_code)]
struct WellKnown {
    tokens_empty: TokenStream,
    tokens_false: TokenStream,
    tokens_true: TokenStream,
}

impl<'a> Gen<'a> {
    fn new(ifc: &'a Ifc, options: &'a Options) -> Self {
        Self {
            ifc,
            options,
            wk: WellKnown {
                tokens_empty: quote!(),
                tokens_false: quote!(false),
                tokens_true: quote!(true),
            },
        }
    }
}

pub fn gen_rust(ifc: &Ifc, options: &Options) -> Result<TokenStream> {
    let gen = Gen::new(ifc, options);

    let mut output = TokenStream::new();
    output.extend(gen.gen_crate_start()?);
    output.extend(gen.gen_types()?);
    Ok(output)
}

impl<'a> Gen<'a> {
    fn gen_crate_start(&self) -> Result<TokenStream> {
        Ok(quote! {
            //! This code was generated by `gen_rust` from C++ definitions, sourced through IFC.
            #![allow(non_camel_case_types)]
            #![allow(non_snake_case)]
            #![allow(non_upper_case_globals)]
        })
    }

    fn gen_types(&self) -> Result<TokenStream> {
        self.gen_types_for_scope(self.ifc.file_header().global_scope, 50)
    }

    /// Recursively walks a scope and generates type definitions for it.
    fn gen_types_for_scope(&self, parent_scope: ScopeIndex, max_depth: u32) -> Result<TokenStream> {
        let mut output = TokenStream::new();

        info!(
            "Scope #{}{}",
            parent_scope,
            if parent_scope == self.ifc.file_header().global_scope {
                " - Global scope"
            } else {
                ""
            }
        );
        // `scope.descriptor` gives us the start and length of the region in `scope.members` where
        // the members for this scope can be found.
        let scope_descriptor = self.ifc.scope_desc().entry(parent_scope - 1)?;

        if max_depth == 0 {
            bail!("Max depth exceeded!");
        }

        let _max_depth = max_depth - 1;

        let scope_members = self.ifc.scope_member();

        for member_index in
            scope_descriptor.start..scope_descriptor.start + scope_descriptor.cardinality
        {
            let member_decl_index: DeclIndex = *scope_members.entry(member_index)?;

            match member_decl_index.tag() {
                DeclSort::ALIAS => {
                    let decl_alias = self.ifc.decl_alias().entry(member_decl_index.index())?;
                    let alias_name = self.ifc.get_string(decl_alias.name)?;
                    info!("    alias: {}", alias_name);
                    info!("{:#?}", decl_alias);
                }

                DeclSort::FUNCTION => {
                    let func_decl = self.ifc.decl_function().entry(member_decl_index.index())?;
                    let _func_name = match func_decl.name.tag() {
                        NameSort::IDENTIFIER => {
                            self.ifc.get_string(func_decl.name.index())?.to_string()
                        }
                        _ => format!("{:?}", func_decl.name),
                    };

                    let _type_str = self.ifc.get_type_string(func_decl.type_)?;
                }

                DeclSort::SCOPE => {
                    let nested_scope = self.ifc.decl_scope().entry(member_decl_index.index())?;
                    // let nested_scope_name = ifc.get_string(nested_scope.name.index())?;

                    // What kind of scope is it?
                    if self.ifc.is_type_namespace(nested_scope.ty)? {
                        // info!("    namespace {} {{ ... }}", nested_scope_name);
                    } else {
                        // info!(
                        //     "    nested scope: name: {:#?} - {:?}",
                        //     nested_scope_name, nested_scope.ty
                        // );
                    }

                    // info!("{:#?}", nested_scope);

                    // if scope.initializer != 0 {
                    //     dump_scope(ifc, scope.initializer, max_depth)?;
                    // }
                }

                DeclSort::FIELD => {
                    let field = self.ifc.decl_field().entry(member_decl_index.index())?;
                    let field_name = self.ifc.get_string(field.name)?;
                    let field_type_string = self.ifc.get_type_string(field.ty)?;
                    info!("    field: {} : {}", field_name, field_type_string);
                }

                DeclSort::METHOD => {}

                DeclSort::ENUMERATION => {
                    let en = self.ifc.decl_enum().entry(member_decl_index.index())?;
                    let t = self.gen_enum(&en)?;
                    output.extend(t);
                }

                DeclSort::VARIABLE => {
                    let t = self.gen_variable(member_decl_index.index())?;
                    output.extend(t);
                }

                _ => {
                    nyi!();
                    info!("unknown decl: {:?}", member_decl_index);
                }
            }
        }

        Ok(output)
    }

    fn gen_variable(&self, var_index: u32) -> Result<TokenStream> {
        let var = self.ifc.decl_var().entry(var_index)?;

        if var.name.tag() != NameSort::IDENTIFIER {
            info!("Found VARIABLE, but its name is not IDENTIFIER.  Ignoring.");
            return Ok(quote!());
        }
        let var_name = self.ifc.get_string(var.name.index())?;
        info!("----- var: {} -----", var_name);

        let var_ident = Ident::new(&var_name, Span::call_site());

        info!("VarDecl: {}", var_name);
        info!("{:?}", var);

        let is_const;
        if var.traits.contains(ObjectTraits::CONSTEXPR) {
            is_const = true;
        } else {
            if self.ifc.is_const_qualified(var.ty)? {
                // If it has a literal initializer, it's a constant.
                if self.ifc.is_literal_expr(var.initializer)? {
                    is_const = true;
                } else {
                    is_const = false;
                }
            } else {
                is_const = false;
            }
        }

        if is_const {
            let ty_tokens = self.get_type_tokens(var.ty)?;
            let init_tokens = self.gen_expr_tokens(var.ty, var.initializer)?;
            Ok(quote! {
                pub const #var_ident: #ty_tokens = #init_tokens;
            })
            // } else if var.specifier.contains(BasicSpecifiers::EXTERNAL) {
        } else {
            // This is a variable declaration, not a definition. We can emit an "extern static" item.
            let ty_tokens = self.get_type_tokens(var.ty)?;

            let mut_kw = if self.ifc.is_const_qualified(var.ty)? {
                quote!(mut)
            } else {
                quote!()
            };

            Ok(quote! {
                extern "C" {
                    pub static #mut_kw #var_ident: #ty_tokens;
                }
            })
        }
    }

    fn get_type_tokens(&self, mut type_index: TypeIndex) -> Result<TokenStream> {
        // Remove qualifiers.
        let mut const_qual = false;
        while type_index.tag() == TypeSort::QUALIFIED {
            let qt = self.ifc.type_qualified().entry(type_index.index())?;
            if qt.qualifiers.contains(Qualifiers::CONST) {
                const_qual = true;
            }
            type_index = qt.unqualified_type;
        }

        Ok(match type_index.tag() {
            TypeSort::FUNDAMENTAL => {
                let fun_ty = self.ifc.type_fundamental().entry(type_index.index())?;
                let is_signed = matches!(fun_ty.sign, TypeSign::SIGNED | TypeSign::PLAIN);

                match fun_ty.basis {
                    TypeBasis::INT => match (fun_ty.precision, is_signed) {
                        (
                            TypePrecision::DEFAULT | TypePrecision::LONG | TypePrecision::BIT32,
                            true,
                        ) => {
                            quote!(i32)
                        }
                        (
                            TypePrecision::DEFAULT | TypePrecision::LONG | TypePrecision::BIT32,
                            false,
                        ) => quote!(u32),
                        (TypePrecision::BIT8, true) => quote!(i8),
                        (TypePrecision::BIT8, false) => quote!(u8),
                        (TypePrecision::BIT16, true) => quote!(i16),
                        (TypePrecision::BIT16, false) => quote!(u16),
                        (TypePrecision::BIT64, true) => quote!(i64),
                        (TypePrecision::BIT64, false) => quote!(u64),
                        (TypePrecision::BIT128, true) => quote!(i128),
                        (TypePrecision::BIT128, false) => quote!(u128),
                        (TypePrecision::SHORT, true) => quote!(i16),
                        (TypePrecision::SHORT, false) => quote!(u16),
                        _ => todo!("unrecognized INT type: {:?}", fun_ty),
                    },

                    TypeBasis::CHAR => match (fun_ty.precision, is_signed) {
                        (TypePrecision::DEFAULT, true) => quote!(i8),
                        (TypePrecision::DEFAULT, false) => quote!(u8),
                        _ => {
                            todo!("unrecognized CHAR type: {:?}", fun_ty);
                        }
                    },

                    TypeBasis::FLOAT | TypeBasis::DOUBLE => {
                        if fun_ty.precision != TypePrecision::DEFAULT {
                            bail!("Floating-point types must have default precision");
                        }
                        if fun_ty.sign != TypeSign::PLAIN {
                            bail!("Floating-point types must have default sign");
                        }
                        if fun_ty.basis == TypeBasis::FLOAT {
                            quote!(f32)
                        } else {
                            quote!(f64)
                        }
                    }

                    TypeBasis::BOOL => quote!(bool),

                    TypeBasis::WCHAR_T => quote!(u16),

                    _ => todo!("TypeBasis: {:?}", fun_ty.basis),
                }
            }

            TypeSort::POINTER => {
                let pointed_ty = *self.ifc.type_pointer().entry(type_index.index())?;
                let pointed_ty_tokens = self.get_type_tokens(pointed_ty)?;
                if const_qual {
                    quote! {*const #pointed_ty_tokens}
                } else {
                    quote! {*mut #pointed_ty_tokens}
                }
            }

            TypeSort::ARRAY => {
                let type_array = self.ifc.type_array().entry(type_index.index())?;
                let element_tokens = self.get_type_tokens(type_array.element)?;
                let extent_tokens = if type_array.extent.tag() == ExprSort::EMPTY {
                    quote!(_)
                } else {
                    quote!(42)
                    // gen_expr_tokens(ifc, type_array.extent)?
                };

                quote! {
                    [#element_tokens; #extent_tokens]
                }
            }

            _ => todo!("unrecognized type sort: {:?}", type_index),
        })
    }

    // This converts literal expressions into token streams.
    fn gen_expr_tokens(&self, ty: ifc::TypeIndex, expr: ifc::ExprIndex) -> Result<TokenStream> {
        let ty = self.ifc.remove_qualifiers(ty)?;

        Ok(match expr.tag() {
            ExprSort::LITERAL => {
                let literal = self.ifc.expr_literal().entry(expr.index())?;
                debug!("literal = {:?}", literal);

                // It appears the "type" field in ExprLiteral is always set to 0, which is
                // VENDOR_EXTENSION.  So we don't actually know the type of the literal.

                if ty.tag() != TypeSort::FUNDAMENTAL {
                    bail!(
                        "gen_expr_tokens: This only works with TypeSort::FUNDAMENTAL, not {:?}",
                        ty
                    );
                }
                let fun_ty = self.ifc.type_fundamental().entry(ty.index())?;
                debug!("gen_expr_tokens: fun_ty {:?}", fun_ty);

                match literal.value.tag() {
                    LiteralSort::IMMEDIATE => {
                        let value: u32 = literal.value.index();
                        trace!("LiteralSort::IMMEDIATE: value = 0x{:x} {}", value, value);
                        if fun_ty.basis == TypeBasis::BOOL {
                            if value != 0 {
                                quote!(true)
                            } else {
                                quote!(false)
                            }
                        } else {
                            let lit = syn::LitInt::new(&value.to_string(), Span::call_site());
                            quote!(#lit)
                        }
                    }
                    LiteralSort::INTEGER => {
                        let value: u64 = *self.ifc.const_i64().entry(literal.value.index())?;
                        trace!("LiteralSort::INTEGER: value = 0x{:x} {}", value, value);
                        if fun_ty.basis == TypeBasis::BOOL {
                            if value != 0 {
                                quote!(true)
                            } else {
                                quote!(false)
                            }
                        } else {
                            if matches!(fun_ty.sign, TypeSign::SIGNED | TypeSign::PLAIN) {
                                let value_i64: i64 = value as i64;
                                if value_i64 < 0 {
                                    if let Some(value_pos) = value_i64.checked_abs() {
                                        let lit = syn::LitInt::new(
                                            &value_pos.to_string(),
                                            Span::call_site(),
                                        );
                                        quote!(-#lit)
                                    } else {
                                        bail!(
                                        "Negative value is -MAX_INT, not sure how to handle that."
                                    );
                                    }
                                } else {
                                    let lit =
                                        syn::LitInt::new(&value.to_string(), Span::call_site());
                                    quote!(#lit)
                                }
                            } else {
                                let lit = syn::LitInt::new(&value.to_string(), Span::call_site());
                                quote!(#lit)
                            }
                        }
                    }
                    LiteralSort::FLOATING_POINT => {
                        todo!("floating point literals")
                    }
                    _ => todo!("unrecognized literal value: {:?}", literal.value),
                }
            }

            ExprSort::DYAD => {
                let dyad = self.ifc.expr_dyad().entry(expr.index())?;
                bail!("ExprSort::DYAD: {:?}", dyad);
            }

            _ => todo!("unsupported expr: {:?}", expr),
        })
    }

    fn get_literal_expr_as_u64(&self, expr: ifc::ExprIndex) -> Result<u64> {
        Ok(match expr.tag() {
            ExprSort::LITERAL => {
                let literal = self.ifc.expr_literal().entry(expr.index())?;
                match literal.value.tag() {
                    LiteralSort::IMMEDIATE => literal.value.index() as u64,
                    LiteralSort::INTEGER => *self.ifc.const_i64().entry(literal.value.index())?,
                    LiteralSort::FLOATING_POINT => {
                        todo!("floating point literals")
                    }
                    _ => todo!("unrecognized literal value: {:?}", literal.value),
                }
            }

            _ => todo!("unsupported expr: {:?}", expr),
        })
    }

    fn gen_enum(&self, enum_decl: &DeclEnum) -> Result<TokenStream> {
        // let en = ifc.decl_enum().entry(member_decl_index.index())?;
        let en_name = self.ifc.get_string(enum_decl.name)?;
        let en_ident = Ident::new(&en_name, Span::call_site());

        // info!("enumeration decl:\n{:#?}", enum_decl);

        // Is this an ordinary enum, or an enum class?
        if enum_decl.ty.tag() != TypeSort::FUNDAMENTAL {
            bail!("Expected DeclEnum.ty to be TypeSort::FUNDAMENTAL");
        }
        let en_ty = self.ifc.type_fundamental().entry(enum_decl.ty.index())?;
        let is_enum_class = match en_ty.basis {
            TypeBasis::CLASS | TypeBasis::STRUCT => true,
            TypeBasis::ENUM => false,
            _ => {
                info!(
                    "warning: enum type basis is not recognized: {:?}",
                    en_ty.basis
                );
                false
            }
        };

        // Determine the storage type of the enum.  The default is int (i32).
        if enum_decl.base.tag() != TypeSort::FUNDAMENTAL {
            bail!("Expected DeclEnum.base to be TypeSort::FUNDAMENTAL");
        }

        let storage_ty: TokenStream = self.get_type_tokens(enum_decl.base)?;

        // Generate the enum type tokens.

        let mut output = quote! {
            #[repr(transparent)]
            #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
            #[cfg_attr(feature = "zerocopy", derive(::zerocopy::AsBytes, ::zerocopy::FromBytes))]
            pub struct #en_ident(pub #storage_ty);
        };

        let mut variants_tokens = TokenStream::new();
        let want_derive_debug = self.options.derive_debug;

        let mut derive_debug_body = TokenStream::new();

        // If an enum has more than one enumerator with the same type, then we need to avoid
        // emitting more than one match arm for that value.
        let mut value_seen: HashSet<u64> = HashSet::new();

        for var_index in enum_decl.initializer.to_range() {
            let var = self.ifc.decl_enumerator().entry(var_index)?;
            let var_name_string = self.ifc.get_string(var.name)?;
            let var_name_ident = Ident::new(&var_name_string, Span::call_site());

            let initializer = self.gen_expr_tokens(enum_decl.base, var.initializer)?;
            variants_tokens.extend(quote! {
                pub const #var_name_ident: #en_ident = #en_ident(#initializer);
            });

            if want_derive_debug {
                let initializer_as_u64 = self.get_literal_expr_as_u64(var.initializer)?;
                if value_seen.insert(initializer_as_u64) {
                    if is_enum_class {
                        derive_debug_body.extend(quote! {
                            Self::#var_name_ident => #var_name_string,
                        });
                    } else {
                        derive_debug_body.extend(quote! {
                            #var_name_ident => #var_name_string,
                        });
                    }
                }
            }
        }

        if is_enum_class {
            output.extend(quote! {
                impl #en_ident {
                    #variants_tokens
                }
            });
        } else {
            output.extend(variants_tokens);
        }

        if want_derive_debug {
            output.extend(quote! {
                impl core::fmt::Debug for #en_ident {
                    // If the enum defines an enumerator for every possible value, then we don't
                    // want to report an error.
                    #[allow(unreachable_patterns)]
                    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                        let s: &str = match *self {
                            #derive_debug_body
                            _ => {
                                return write!(fmt, "({})", self.0);
                            }
                        };
                        fmt.write_str(s)
                    }
                }
            });
        }

        parse_check_mod_items(&output)?;
        Ok(output)
    }
}

fn parse_check<T: syn::parse::Parse>(t: &TokenStream) -> Result<()> {
    let tt = t.clone();
    match syn::parse2::<T>(tt) {
        Ok(_) => Ok(()),
        Err(e) => {
            info!("FAILED to parse token stream with expected type.");
            info!("Error: {:?}", e);
            info!("Token stream:\n{}", t);
            Err(e.into())
        }
    }
}

// Check that `t` can be successfully parsed as a sequence of items inside a mod.
fn parse_check_mod_items(t: &TokenStream) -> Result<()> {
    let mod_t = quote! {
        mod foo {
            #t
        }
    };

    parse_check::<syn::ItemMod>(&mod_t)
}
